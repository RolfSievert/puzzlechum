#! /usr/bin/env python
# -*- coding: utf-8 -*-
# vim:fenc=utf-8

"""
Runs tests on provided problem id.
"""

from pathlib import Path
import subprocess
import argparse

RED = '\x1b[38;5;3m'
BLUE = '\x1b[38;5;2m'
GREEN = '\x1b[38;5;1m'
YELLOW = '\x1b[38;5;4m'
BOLD = '\x1b[1m'
DIMMED = '\x1b[2m'
ITALICS = '\x1b[3m'
NULL = '\x1b[0m'

ACCEPTED_SRC_SUFFIXES = [
    '.cpp',
    '.rs'
]

PROBLEM_ROOT = Path("./problems")

TMP_PATH = Path("./.runtest_tmp")

BINARY_EXECUTION_COMMAND = ' < {} > ' + f'{TMP_PATH / "output"}'

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("problem_name")
    parser.add_argument("-t", help="sum execution time over t iterations", type=int, default=0)
    return parser.parse_args()

def get_test_files(test_dir, local_test_dir):
    ans = []
    ins = []

    for d in [test_dir, local_test_dir]:
        if d.is_dir():
            ans += d.glob('*.ans')
            ins += d.glob('*.in')

    # remove test files that don't have both .in and .ans
    ans = [a for a in ans if str(a.parent / a.stem) in [str(i.parent / i.stem) for i in ins]]
    ins = [i for i in ins if str(i.parent / i.stem) in [str(a.parent / a.stem) for a in ans]]

    ans = sorted(ans)
    ins = sorted(ins)

    return list(zip([str(x) for x in ins], [str(x) for x in ans]))

def check_create_tmp_dir():
    if not TMP_PATH.is_dir():
        try:
            TMP_PATH.mkdir()
        except (FileExistsError, FileNotFoundError) as err:
            print("Could not create {TMP_PATH}:", err)

def is_accepted_src_file(file_path, problem_name):
    return \
        file_path.is_file() \
        and file_path.name.startswith(problem_name) \
        and file_path.suffix in ACCEPTED_SRC_SUFFIXES

def run_test(test_execution_command, in_file, times):
    # use format to insert test file path
    exec_command = test_execution_command.format(in_file)

    if times:
        time_command = '/usr/bin/time --format="%e %U %S"'
        loop = 'for i in {1..' + str(times) + '}; do (' + exec_command + ') >/dev/null 2>&1; done'
        exec_command = f'{time_command} sh -c "{loop}"'

    stderr_output = subprocess.check_output([exec_command], stderr=subprocess.STDOUT, shell=True)
    if times and stderr_output:
        real, user, system = stderr_output.decode().split()
        print(f'{DIMMED}{in_file}{NULL}')
        print('{}  real {} user {} system {} U+S {:.2f}{}'.format(DIMMED, real, user, system, float(user) + float(system), NULL))

def get_source_files(problem_name):
    problem_dir = PROBLEM_ROOT / problem_name
    return [x for x in problem_dir.iterdir() if is_accepted_src_file(x, problem_name)]


def compile_and_get_test_commands(source_files, problem_dir, problem_name):
    run_commands = []

    # TODO extend to handle more languages
    for src in source_files:
        output_executable = TMP_PATH / f'prg_{src.suffix[1:]}'

        if src.suffix == '.cpp':
            CC = f'g++ -std=c++17 -O2 -Wall -pedantic -o {output_executable} -I {problem_dir}'
        elif src.suffix == '.rs':
            # see https://open.kattis.com/help/rust
            CC = f'rustc -o {output_executable} --crate-type bin --edition=2018'

        # build executable
        subprocess.call(f'{CC} {src}', shell=True)

        run_commands.append((f'{output_executable} {BINARY_EXECUTION_COMMAND}', src))

    return run_commands

def check_test(ans_file):
    # output logging
    stack_max_size = 16
    output_stack = []
    success = True

    # compare output and answers
    """
    If all correct, don't print.

    Print stack of previously corrected lines as green.

    Print wrong output and all following as red.

    Print expected output.
    """
    with open(TMP_PATH / 'output', 'r') as o_file, open(Path(ans_file), 'r') as a_file:
        for line, a_line in enumerate(a_file):
            # only check when input has a non-whitespace
            if not a_line.isspace():
                o_line = o_file.readline()
                while o_line.isspace():
                    o_line = o_file.readline()

                # lines are not the same (excluding whitespace)
                if a_line.split() != o_line.split():
                    success = False
                    for o in output_stack:
                        if o == output_stack[-1]:
                            print(f"{GREEN}{o}{NULL}", end='')
                        else:
                            print(o)
                    print(f"{YELLOW}{ans_file}{NULL} failed at line {line+1}")
                    print(f"EXPECTED: {BLUE}{a_line}{NULL}")
                    # strip endlines etc with rstrip
                    print(f"{RED}{o_line}{NULL}", end='')
                    print(f"{RED}{o_file.read()}{NULL}")

                    # Print rest of expected output
                    a_dump = a_file.read()
                    if (a_dump):
                        print("ANSWERS:")
                        print(a_dump)

                # save output
                output_stack.append(o_line)
                if len(output_stack) > stack_max_size:
                    output_stack.pop(0)
        # When done reading answers, check that there are not any residual in output
        rest = o_file.read()
        if rest:
            success = False
            print(f"{YELLOW}{ans_file}{NULL} got trailing output:");
            print(f"{RED}{rest}{NULL}\n")

    return success

def __main__():
    args = parse_args()
    problem_dir = PROBLEM_ROOT / args.problem_name

    test_dir = Path('./tests') / args.problem_name
    local_test_dir = problem_dir / 'test'
    testing_tuples = get_test_files(test_dir, local_test_dir)

    check_create_tmp_dir()

    source_files = get_source_files(args.problem_name)
    sources_string = ', '.join(str(src) for src in source_files)
    print(f'{DIMMED}Compiling source files... [{sources_string}]{NULL}')
    test_commands = compile_and_get_test_commands(source_files, problem_dir, args.problem_name)

    if not sum(1 for _ in testing_tuples):
        print(f"No tests found! Make sure to add both .in and .ans files in '{test_dir}/' or '{local_test_dir}/'.")
    else:
        tests_string = ', '.join(str(test) for test, _ in testing_tuples)
        print(f'{DIMMED}Running tests... [{tests_string}]\n{NULL}')
        for test_command, src_file in test_commands:
            success = True
            for in_file, ans_file in testing_tuples:
                run_test(test_command, in_file, args.t)
                success = success and check_test(ans_file)

            print(src_file)
            if success:
                print(f'{GREEN}  ✔ - PASSED{NULL}')
            else:
                print(f'{RED}  ✗ - FAILED{NULL}')

    # cleanup
    for x in TMP_PATH.iterdir():
        x.unlink()
    TMP_PATH.rmdir()

__main__()
