#! /usr/bin/env python
# -*- coding: utf-8 -*-
# vim:fenc=utf-8

"""
Runs tests on provided problem id.
"""

import sys
from pathlib import Path
import subprocess
import argparse

RED = '\x1b[38;5;3m'
BLUE = '\x1b[38;5;2m'
GREEN = '\x1b[38;5;1m'
YELLOW = '\x1b[38;5;4m'
NULL = '\x1b[0m'

PROBLEM_ROOT = Path("./problems")

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("problem_name")
    parser.add_argument("-t", help="sum execution time over t iterations", type=int, default=0)
    return parser.parse_args()

def get_test_files(test_dir):
    ans = sorted(Path(test_dir).glob('*.ans'))
    ins = sorted(Path(test_dir).glob('*.in'))
    return zip([str(x) for x in ins], [str(x) for x in ans])

def check_create_tmp_dir():
    tmp_dir = Path("tmp")
    if not tmp_dir.is_dir():
        try:
            tmp_dir.mkdir()
        except (FileExistsError, FileNotFoundError) as err:
            print("Could not create {tmp.dir}:", err)

def run_test(test_execution_command, in_file, times):
    # use format to insert test file path
    exec_command = test_execution_command.format(in_file)
    if times:
        time_command = '/usr/bin/time --format="%e %U %S" sh -c '
        exec_command = time_command + "\"for i in {1.." + str(times) + "}; do " + exec_command + "; done\""
    stderr_output = subprocess.check_output([exec_command], stderr=subprocess.STDOUT, shell=True)
    if times and stderr_output:
        real, user, system = stderr_output.decode().split()
        print("real {} user {} system {} U+S {:.2f}".format(real, user, system, float(user) + float(system)))

def compile_and_get_test_command(problem_dir, problem_name):
    # TODO extend to handle more languages
    cpp_path = problem_dir / f'{problem_name}.cpp'
    if cpp_path.is_file():
        CC = f"g++ -std=c++17 -O2 -Wall -pedantic -o tmp/prg -I {problem_dir}"
        subprocess.call(f"{CC} {cpp_path}", shell=True)
        return "./tmp/prg < {} > tmp/output"

    raise(f"No problem solution found! Searched in {str(problem_dir / problem_name)}")

def check_test(ans_file):
    # output logging
    stack_max_size = 16
    output_stack = []
    success = True

    # compare output and answers
    """
    If all correct, don't print.

    Print stack of previously corrected lines as green.

    Print wrong output and all following as red.

    Print expected output.
    """
    with open('tmp/output', 'r') as o_file, open(Path(ans_file), 'r') as a_file:
        for line, a_line in enumerate(a_file):
            # only check when input has a non-whitespace
            if not a_line.isspace():
                o_line = o_file.readline()
                while o_line.isspace():
                    o_line = o_file.readline()

                # lines are not the same (excluding whitespace)
                if a_line.split() != o_line.split():
                    success = False
                    for o in output_stack:
                        if o == output_stack[-1]:
                            print(f"{GREEN}{o}{NULL}", end='')
                        else:
                            print(o)
                    print(f"{YELLOW}{ans_file}{NULL} failed at line {line+1}")
                    print(f"EXPECTED: {BLUE}{a_line}{NULL}")
                    # strip endlines etc with rstrip
                    print(f"{RED}{o_line}{NULL}", end='')
                    print(f"{RED}{o_file.read()}{NULL}")

                    # Print rest of expected output
                    a_dump = a_file.read()
                    if (a_dump):
                        print("ANSWERS:")
                        print(a_dump)

                # save output
                output_stack.append(o_line)
                if len(output_stack) > stack_max_size:
                    output_stack.pop(0)
        # When done reading answers, check that there are not any residual in output
        rest = o_file.read()
        if rest:
            success = False
            print(f"{YELLOW}{ans_file}{NULL} got trailing output:");
            print(f"{RED}{rest}{NULL}\n")

    return success

def __main__():
    args = parse_args()
    problem_dir = PROBLEM_ROOT / args.problem_name

    test_dir = Path('tests', args.problem_name)
    testing_tuples = get_test_files(test_dir)

    check_create_tmp_dir()

    print("Compiling program...")
    test_execution_command = compile_and_get_test_command(problem_dir, args.problem_name)

    print("Running tests...")
    success = True
    for in_file, ans_file in testing_tuples:
        run_test(test_execution_command, in_file, args.t)
        success = success and check_test(ans_file)

    if success:
        print("{}âœ” - AC{}".format(GREEN, NULL))
        # cleanup
        subprocess.run('rm -rf tmp', shell=True)

__main__()
